# Javascript Questions

- [var, let, const를 이용해 hoisting과 TDZ에 대해 설명해 주세요.](#var-let-const를-이용해-hoisting과-tdz에-대해-설명해-주세요)
- [자바스크립트로 CSS를 조작하다보면 FOUC(Flash of Unstyled Content)가 발생하는 경우가 있는데, 이 현상이 DOM과 어떤 관련이 있는지 설명해보실래요?](#자바스크립트로-css를-조작하다보면-foucflash-of-unstyled-content가-발생하는-경우가-있는데-이-현상이-dom과-어떤-관련이-있는지-설명해보실래요)
- [자바스크립트의 배열은 일반적인 리스트 자료구조와 어떤 차이가 있나요?](#자바스크립트의-배열은-일반적인-리스트-자료구조와-어떤-차이가-있나요)
- [이벤트 루프와 테스크 큐에 대해 설명해 주세요.](#이벤트-루프와-테스크-큐에-대해-설명해-주세요)
- [객체지향 프로그래밍과 특징에 대해 설명해 주세요.](#객체지향-프로그래밍과-특징에-대해-설명해-주세요)
- [자바스크립트의 비동기 처리 방법인 promise와 async/await에 대해 설명해 주세요.](#자바스크립트의-비동기-처리-방법인-promise와-asyncawait에-대해-설명해-주세요)
- [스코프에 대해 설명해주세요.](#스코프에-대해-설명해주세요)
- [ajax에 대해 설명해주세요.](#ajax에-대해-설명해주세요)
- [이벤트 버블링과 캡쳐링이 무엇인지, 이벤트 위임은 어떻게 하는지 설명해주세요.](#이벤트-버블링과-캡쳐링이-무엇인지-이벤트-위임은-어떻게-하는지-설명해주세요)

# Answers

## var, let, const를 이용해 hoisting과 TDZ에 대해 설명해 주세요.

실행 컨텍스트가 활성화 될 때(코드를 수행할 때), 자바스크립트 엔진은 해당 컨텍스트의 코드를 실행하는 데 필요한 정보를 실행 컨텍스트에 저장합니다.

이 때 environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보가 저장되는데, 컨텍스트의 처음부터 끝까지 확인하여 이 식별자들을 확인하는 과정이 hoisting 입니다.

var, let, const는 모두 hoisting을 통해 식별자 정보가 최상단으로 끌어올려지지만, 차이가 존재합니다.

var 의 경우에는 environmentRecord가 인스턴스화 될 때 undefined로 초기화 되지만, let과 const는 실제 식별자에 값이 할당되기 전에는 접근할 수 없습니다.

즉, var와는 다르게 let과 const는 undefined로 초기화 되지 않으며, 메모리에 할당되지 않기 때문에 변수가 생성된 이후 할당되기 전 일시적으로 접근할 수 없는 그 상태를 TDZ라고 부릅니다.

## 자바스크립트로 CSS를 조작하다보면 FOUC(Flash of Unstyled Content)가 발생하는 경우가 있는데, 이 현상이 DOM과 어떤 관련이 있는지 설명해보실래요?

FOUC는 브라우저의 동작방식과 연관이 있습니다.

브라우저는 HTML, CSS, JS 순서로 파일을 받아오는데, 여기서 CSS가 적용이 되지 않은 상태의 DOM이 화면에 나타나게 되면 발생하는 문제입니다.

자바스크립트로 DOM을 동적으로 조작할 때, JS 파일이 CSS 파일을 import 하고 있을 경우 발생할 수 있습니다.

이를 해결하기 위해선 자바스크립트에서 import 하는 코드를 제거해 HTML에서 해당 CSS 파일을 링크하거나,
성능에 불이익을 가져다 줄 순 있지만 HTML의 head태그에서 script태그를 작성해 자바스크립트를 우선적으로 로드하게 하여 해결할 수 있습니다.

## 자바스크립트의 배열은 일반적인 리스트 자료구조와 어떤 차이가 있나요?

[자바스크립트 배열은 배열이 아니다](https://poiemaweb.com/js-array-is-not-arrray)

일반적인 배열은 메모리 공간의 빈틈이 없이 연속적으로 나열된 자료 구조이다.

이는 O(1)로 접근할 수 있으며, 매우 효율적이지만 반대로 특정 값을 탐색하는 경우 O(n)의 시간 복잡도를 지닌다.

또한 삽입, 삭제의 경우 배열 요소를 연속적으로 유지하기 위해 요소를 이동시켜야 하므로 불리하다.

하지만 자바스크립트의 배열은 각 메모리 공간이 동일한 크기를 가지고 있지 않으며 연속적으로 이어지지 않아도 된다.

마치 희소배열 처럼 동작하는 자바스크립트의 배열은 사실 일반적인 배열의 동작을 흉내내는 특수한 객체이다.

자바스크립트 배열은 해시 테이블로 구현된 객체이므로 베열 요소에 접근하는 경우 추가적인 연산이 필요하지만, 대신 삽입 및 삭제하는 경우에는 더 빠른 성능을 기대할 수 있다.

인덱스로 접근시에 느릴수 밖에 없는 단점을 보완하기 위해 모던 자바스크립트 엔진은 배열을 일반 객체와 구별하여 보다 배열처럼 동작하도록 구현되어 있다.

## 이벤트 루프와 테스크 큐에 대해 설명해 주세요

자바스크립트는 싱글스레드이기 때문에 시간이 오래 걸리는 작업을 수행할 경우 뒤의 테스크들이 블로킹 될 수 있습니다.
따라서 브라우저에서는 이벤트 루프를 통해 자바스크립트의 동시성을 지원할 수 있습니다.

비동기 방식으로 동작하는 함수들의 실행은 자바스크립트 엔진이 담당하지만, setTimeout등의 호출 스케쥴링과 타이머 설정은
브라우저 혹은 Node.js가 담당합니다. 이를 위해 브라우저에서는 테스트 큐와 이벤트 루프를 지원합니다.

테스크 큐는 비동기 함수의 콜백 함수 혹은 이벤트 핸들러가 일시적으로 보관되는 영역입니다.

이벤트 루프는 콜 스택에 현재 실행중인 실행 컨텍스트가 있는지 확인하고, 테스크 큐에 대기중인 함수가 있는지 확인합니다.
만약 콜 스택이 비어있고, 테스크 큐에 대기중인 함수가 있다면 이벤트 루프는 FIFO로 태스크 큐의 함수를 콜 스택으로 이동시킵니다.

테스크 큐도 마이크로 태스트, 매크로 태스트 2가지로 나뉠 수 있습니다.
마이크로 테스크는 프로미스 핸들러 등 비동기 통신, 매크로 태스크는 DOM 이벤트 콜백, 타이머, 스크립트 로딩 등이 있으며
콜 스택이 비어있을 경우 이벤트 루프는 마이크로 테스크를 먼저 콜스택으로 옮깁니다.

```javascript
console.log('call stack');
setTimeout(() => console.log('macro task'), 0);
Promise.resolve().then(() => console.log('micro task'));

// 출력 순서
// call stack
// micro task
// macro task
```

## 객체지향 프로그래밍과 특징에 대해 설명해 주세요.

객체지향 프로그래밍은 프로그램을 객체로 바라보는 관점 입니다.

각 독립된 객체를 조립해서 사용하는 방식은, 재사용이 가능한 객체들을 많이 만들고, 이 객체들의 재사용성을 높이기 위해 아래와 같은 개념들이 나오게 되었습니다.

- 캡슐화

작은 문재를 해결하는 독립된 객체를 사용하면서 객체 내 모든 데이터에 접근할 필요가 없으므로,
외부로 노출해야 하는 값과 내부에서만 사용하는 값을 구분합니다. 이를 데이터를 보호하는 캡슐로 비유하여 내부 데이터에 접근하지 못하게 하고 필요한 메소드만 열어두는 특성을 캡슐화 라고 부릅니다.

- 상속

객체를 재사용 하는것은 좋지만, 객체 내 모든 데이터를 활용하진 않으므로 객체의 일부분만 재사용을 하는 방법이 필요하게 되었습니다. 따라서 여러 객체의 공통된 부분을 만들어 그 코드를 상속 받는것이 중요합니다.

- 추상화

사과, 바나나, 배 등을 하나의 카테고리인 과일로 묶는 것처럼 공통적인 부분을 모아 상위의 개념으로 이름을 붙이는 것을 추상화 라고 합니다.

- 다형성

상속과 추상화를 통해 객체를 만들게 되면, 여러 객체가 동일한 메서드를 실행하는 것으로 같은 취급을 할 수 있습니다. 추상화된 객체는 여러 타입으로 참조할 수 있는 개념이 다형성 입니다.
다형성을 통해 객체의 일부분을 여러가지 방법으로 재사용 하도록 설계할 수 있습니다.

## 자바스크립트의 비동기 처리 방법인 Promise와 async/await에 대해 설명해 주세요.

[[Javascript] 비동기, Promise, async, await 확실하게 이해하기](https://springfall.cc/article/2022-11/easy-promise-async-await)

Promise는 기존의 비동기 처래 패턴인 콜백 함수를 개선하기 위해 ES6에서 나온 문법입니다.

Promise는 executor라는 함수를 생성하며, 생성시 첫번째 인자로 resolve, 두번째 인자로 reject 함수를 받으며 resolve는 비동기 작업 성공, reject는 비동기 작업 실패시 동작하는 함수입니다.

대기(pending), 이행(fulfilled), 거부(rejected) 3가지 상태를 가지고 있으며, 이행 상태일 때 then, 거부 상태일 때 catch 로 등록한 동작들이 실행됩니다

async / await 키워드는 비동기 함수를 더 쉽게 작성할 수 있도록 ES7에서 나온 문법입니다.
async 키워드가 붙은 함수는 무조건 Promise를 반환하며, await은 아래의 특징이 있습니다.

- await 키워드는 async로 선언된 함수 내에서만 사용할 수 있습니다.
- await 은 Promise 가 완료될 때까지 기다립니다.
- await 은 Promise 가 resolve 한 값을 반환합니다.
- 해당 Promise 에서 reject 가 발생한다면 예외가 발생합니다

이처럼 await은 기존 Promise에서 직접 then, catch를 이용해 작성하던 내용을 쉽게 컨트롤 할 수 있게 해줍니다.

## 스코프에 대해 설명해주세요.

[자바스크립트 스코프](https://poiemaweb.com/js-scope)

스코프는 범위 라는 뜻으로, 식별자/변수가 유효한 범위를 의미합니다.

스코프는 크게 2가지, 전역 스코프와 지역 스코프로 구분할 수 있습니다.
전역 스코프를 갖는 변수는 프로그램 전역에서 접근할 수 있으며, 지역 스코프를 갖는 변수는 자신 및 하위 스코프에서 유효합니다.

ES5 까지 자바스크립트는 함수 레벨 스코프를 지원했지만, ES6의 let, const를 통해 블록 레벨 스코프 또한 지원합니다.

또한 자바스크립트는 렉시컬 스코프 방식을 따릅니다. 렉시컬 스코프는 함수를 어디서 호출하는지가 아닌, 어디에 호출하였는지에 따라
스코프를 결정하는것을 의미합니다. 즉, 함수를 선언한 시점에 상위 스코프가 결정됩니다.

```
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

## ajax에 대해 설명해주세요.

ajax(Asynchronous JavaScript and XML)는 브라우저가 서버에 자바스크립트를 이용해 비동기로 데이터를 요청/응답해
웹페이지를 동적으로 업데이트 하는 프로그래밍을 의미합니다.

ajax가 나오기 전 웹페이지는 완전한 html 파일을 전송받아 처음부터 페이지를 렌더링 했지만,
ajax를 이용하면 웹페이지가 필요한 데이터만 비동기로 받아와 페이지 전체를 렌더링 하지 않고 일부만을 업데이트 할 수 있습니다.

자바스크립트는 XMLHttpRequest 객체를 이용해 서버에 요청을 보내고, 서버로부터 응답을 받아 웹 페이지를 갱신하는 자바스크립트 코드를 호출합니다.

## 이벤트 버블링과 캡쳐링이 무엇인지, 이벤트 위임은 어떻게 하는지 설명해주세요.

[이벤트 버블링과 캡쳐링](https://ko.javascript.info/bubbling-and-capturing)

버블링은 한 요소에서 이벤트가 발생한 경우 최상단 요소까지 각 요소의 핸들러가 실행하는 현상이며,
이벤트 캡쳐링은 이벤트가 하위 요소로 전파되는 단계 입니다.

이벤트 위임은 연속되는 형제 태그가 공통적인 이벤트를 가질 때, 이벤트 핸들러를 해당 요소들의 부모 요소에 할당하는 것을 의미합니다.  
이 작업을 통해 각 요소마다 이벤트를 지정하지 않고 간결하게 버블링을 이용해 이벤트를 실행할 수 있습니다.

다만, 리액트에서는 이벤트 위임을 쓰지 않고 각각의 태그에 이벤트 핸들러를 할당하는 방법을 권장합니다.
리액트의 virtual DOM 이벤트 시스템에서 이벤트 위임과 같은 동작을 수행하기 때문에 useRef등을 이용해 dom에 접근하여
이벤트 위임을 하는것이 큰 의미가 없습니다.
