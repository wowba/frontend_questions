# React Questions

- [제어 컴포넌트와 비제어 컴포넌트에 대해서 설명해보시고, 어떤 경우에 어떤 컴포넌트를 사용해야 좋을지 말씀해 주세요.](#제어-컴포넌트와-비제어-컴포넌트에-대해서-설명해보시고-어떤-경우에-어떤-컴포넌트를-사용해야-좋을지-말씀해-주세요)
- [리액트의 특징 중 선언형 프로그래밍에 대해 설명해 주세요. 그리고 왜 선언형으로 작성해야 하나요?](#리액트의-특징-중-선언형-프로그래밍에-대해-설명해-주세요-그리고-왜-선언형으로-작성해야-하나요)
- [리액트 컴포넌트가 화면에 표시되기 까지 과정에 대해 설명해 주세요.](#리액트-컴포넌트가-화면에-표시되기-까지-과정에-대해-설명해-주세요)
- [리액트와 같은 CSR SPA에서는 어떻게 라우팅을 할 수 있나요?](#리액트와-같은-csr-spa에서는-어떻게-라우팅을-할-수-있나요)
- [FLUX 패턴에 대해 설명해주세요](#flux-패턴에-대해-설명해주세요)

# Answers

## 제어 컴포넌트와 비제어 컴포넌트에 대해서 설명해보시고, 어떤 경우에 어떤 컴포넌트를 사용해야 좋을지 말씀해 주세요.

제어 컴포넌트는 실시간으로 사용자의 입력을 받아 상태(state)를 업데이트 하는 컴포넌트이며,

비제어 컴포넌트는 실시간이 아닌 특정 동작등이 발생할 때 DOM에서 정보를 가져오는 컴포넌트 입니다.

제어 컴포넌트의 경우에는 실시간으로 입력값을 확인해야 하는 경우에서 유용하게 사용할 수 있으며,
실시간으로 값을 확인할 필요가 없는 경우에는 비제어 컴포넌트를 활용할 수 있습니다.

하지만 제어 컴포넌트가 너무 자주 state를 업데이트 하게 되면 이는 성능상의 불이익을 가져올 수 있는데,
이를 throttle 혹은 debounce를 이용하여 최적화 할 수 있습니다.

## 리액트의 특징 중 선언형 프로그래밍에 대해 설명해 주세요. 그리고 왜 선언형으로 작성해야 하나요?

선언형 프로그래밍은 원하는 결과를 묘사하는 방식으로 코드를 작성하는 프로그래밍 방법입니다.

즉, 어떻게 페이지를 렌더링 할것이 아닌 무엇이 페이지에 렌더링 될 것인지 작성하는 것이
리액트의 특징인 선언형 UI 입니다.

간단한 비교로, 순수 자바스크립트를 이용해 새로운 태그를 DOM에 추가하려면
요소를 생성하고, 생성한 요소를 DOM 어디에 추가할 것인지 지정해 주어야 합니다.

하지만 JSX 문법을 이용하면 단순히 HTML 태그를 직접 작성하고 원하는 위치에 넣어주기만 하면
상대적으로 간결하고 결과를 예측하기 쉽게 코드를 작성할 수 있습니다.

리액트는 단순 UI 라이브러리로, JSX문법으로 작성(선언)하면 React element를 생성하는 함수를 리턴하고
생성한 컴포넌트를 관리하는 역할을 하고 있습니다.

위처럼 선언형으로 작성하게 되면 코드가 간결해지고 상대적으로 결과를 예측하기 쉬워지며, 결과적으로
프로그램의 복잡도를 줄일 수 있습니다.

## 리액트 컴포넌트가 화면에 표시되기 까지 과정에 대해 설명해 주세요.

컴포넌트를 Virtual DOM으로 만드는 것을 렌더, 만든 Virtual DOM을 화면에 보여주는것을 Commit 이라고 합니다.

렌더링은 재귀적으로 일어납니다. 첫 렌더링은 createRoot로 루트 컴포넌트를 렌더한 뒤, 해당 컴포넌트다 다른 컴포넌트를 반환하면 React는 반환된 컴포넌트를 다음에 렌더링 해서 더이상 렌더링 할 컴포넌트가 없을때 까지 반복됩니다.

컴포넌트를 렌더링 한 뒤, React는 DOM을 수정합니다.
초기 렌더링의 경우 리액트는 appendChild() DOM API를 사용하며, 이후의 리렌더링은 DOM이 최신 렌더링 결과와 일치하도록 수정합니다.

## 리액트와 같은 CSR SPA에서는 어떻게 라우팅을 할 수 있나요?

클라이언트 사이드 라우팅은 클라이언트의 history 객체를 통해서 주소창의 엔드포인트를 바꾸는 방식으로 동작합니다.
history 객체의 방문기록을 통해 앞, 뒤로 움직일 수 있으며 pushState는 브라우저의 세션 기록 스택에 상태를 추가합니다.

react-router-dom의 browserRouter의 경우 react-router 컴포넌트의 최상위에 위치하며
특정 엔드포인트 마다 컴포넌트를 할당하여 클라이언트 내부에서 엔드포인트 변경시 알맞은 컴포넌트를 반환합니다.

## FLUX 패턴에 대해 설명해주세요
