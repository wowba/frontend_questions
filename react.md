# React Questions

- [제어 컴포넌트와 비제어 컴포넌트에 대해서 설명해보시고, 어떤 경우에 어떤 컴포넌트를 사용해야 좋을지 말씀해 주세요.](#제어-컴포넌트와-비제어-컴포넌트에-대해서-설명해보시고-어떤-경우에-어떤-컴포넌트를-사용해야-좋을지-말씀해-주세요)
- [리액트의 특징 중 선언형 프로그래밍에 대해 설명해 주세요. 그리고 왜 선언형으로 작성해야 하나요?](#리액트의-특징-중-선언형-프로그래밍에-대해-설명해-주세요-그리고-왜-선언형으로-작성해야-하나요)
- [리액트 컴포넌트가 화면에 표시되기 까지 과정에 대해 설명해 주세요.](#리액트-컴포넌트가-화면에-표시되기-까지-과정에-대해-설명해-주세요)
- [리액트와 같은 CSR SPA에서는 어떻게 라우팅을 할 수 있나요?](#리액트와-같은-csr-spa에서는-어떻게-라우팅을-할-수-있나요)
- [FLUX 패턴에 대해 설명해주세요](#flux-패턴에-대해-설명해주세요)
- [React에서 Fragment를 사용하는 이유를 설명해주세요.](#react에서-fragment를-사용하는-이유를-설명해주세요)
- [상태를 관리하는 훅인 useState와 useReducer의 특징과 차이를 설명해주세요.](#상태를-관리하는-훅인-usestate와-usereducer의-특징과-차이를-설명해주세요)
- [불필요한 렌더링 방지를 위해 어떤 방법을 활용할 수 있나요?](#불필요한-렌더링-방지를-위해-어떤-방법을-활용할-수-있나요)

# Answers

## 제어 컴포넌트와 비제어 컴포넌트에 대해서 설명해보시고, 어떤 경우에 어떤 컴포넌트를 사용해야 좋을지 말씀해 주세요.

제어 컴포넌트는 실시간으로 사용자의 입력을 받아 상태(state)를 업데이트 하는 컴포넌트이며,

비제어 컴포넌트는 실시간이 아닌 특정 동작등이 발생할 때 DOM에서 정보를 가져오는 컴포넌트 입니다.

제어 컴포넌트의 경우에는 실시간으로 입력값을 확인해야 하는 경우에서 유용하게 사용할 수 있으며,
실시간으로 값을 확인할 필요가 없는 경우에는 비제어 컴포넌트를 활용할 수 있습니다.

하지만 제어 컴포넌트가 너무 자주 state를 업데이트 하게 되면 이는 성능상의 불이익을 가져올 수 있는데,
이를 throttle 혹은 debounce를 이용하여 최적화 할 수 있습니다.

## 리액트의 특징 중 선언형 프로그래밍에 대해 설명해 주세요. 그리고 왜 선언형으로 작성해야 하나요?

선언형 프로그래밍은 원하는 결과를 묘사하는 방식으로 코드를 작성하는 프로그래밍 방법입니다.

즉, 어떻게 페이지를 렌더링 할것이 아닌 무엇이 페이지에 렌더링 될 것인지 작성하는 것이
리액트의 특징인 선언형 UI 입니다.

간단한 비교로, 순수 자바스크립트를 이용해 새로운 태그를 DOM에 추가하려면
요소를 생성하고, 생성한 요소를 DOM 어디에 추가할 것인지 지정해 주어야 합니다.

하지만 JSX 문법을 이용하면 단순히 HTML 태그를 직접 작성하고 원하는 위치에 넣어주기만 하면
상대적으로 간결하고 결과를 예측하기 쉽게 코드를 작성할 수 있습니다.

리액트는 단순 UI 라이브러리로, JSX문법으로 작성(선언)하면 React element를 생성하는 함수를 리턴하고
생성한 컴포넌트를 관리하는 역할을 하고 있습니다.

위처럼 선언형으로 작성하게 되면 코드가 간결해지고 상대적으로 결과를 예측하기 쉬워지며, 결과적으로
프로그램의 복잡도를 줄일 수 있습니다.

## 리액트 컴포넌트가 화면에 표시되기 까지 과정에 대해 설명해 주세요.

컴포넌트를 Virtual DOM으로 만드는 것을 렌더, 만든 Virtual DOM을 화면에 보여주는것을 Commit 이라고 합니다.

렌더링은 재귀적으로 일어납니다. 첫 렌더링은 createRoot로 루트 컴포넌트를 렌더한 뒤, 해당 컴포넌트다 다른 컴포넌트를 반환하면 React는 반환된 컴포넌트를 다음에 렌더링 해서 더이상 렌더링 할 컴포넌트가 없을때 까지 반복됩니다.

컴포넌트를 렌더링 한 뒤, React는 DOM을 수정합니다.
초기 렌더링의 경우 리액트는 appendChild() DOM API를 사용하며, 이후의 리렌더링은 DOM이 최신 렌더링 결과와 일치하도록 수정합니다.

## 리액트와 같은 CSR SPA에서는 어떻게 라우팅을 할 수 있나요?

클라이언트 사이드 라우팅은 클라이언트의 history 객체를 통해서 주소창의 엔드포인트를 바꾸는 방식으로 동작합니다.
history 객체의 방문기록을 통해 앞, 뒤로 움직일 수 있으며 pushState는 브라우저의 세션 기록 스택에 상태를 추가합니다.

react-router-dom의 browserRouter의 경우 react-router 컴포넌트의 최상위에 위치하며
특정 엔드포인트 마다 컴포넌트를 할당하여 클라이언트 내부에서 엔드포인트 변경시 알맞은 컴포넌트를 반환합니다.

## FLUX 패턴에 대해 설명해주세요

FLUX 패턴은 단반향 데이터 흐름을 가지고 있습니다.
데이터는 디스패쳐 -> 스토어 -> 뷰 순서로 뷰에서 입력이 발생하면 액션을 통해 디스패쳐로 향합니다.

액션이 발생하면 디스패쳐로 액션 객체가 전달되고, 콜백 함수를 통해 스토어로 전달합니다.
액션이 스토어에 접근하기 전에 디스패쳐를 거쳐야 합니다.

스토어는 애플리케이션의 상태를 저장하며, 스토어에 직접 상태 변경을 요청할 수 없습니다.
상태 변경은 반드시 스토어에 의해 결정되며, 상태 변경을 위해선 디스패쳐료 액션을 전달해 원하는 상태변경 요청을 스토어에 전달해야 합니다.

이렇게 스토어의 값이 변경하게 되면 스토어는 뷰에 변경된 값을 전달하고, 뷰는 업데이트 됩니다.

## React에서 Fragment를 사용하는 이유를 설명해주세요.

[\<Fragment> (<>...</>)](https://react-ko.dev/reference/react/Fragment)

Fragment는 React 16에서 추가된 기능입니다.

React에서 하나의 컴포넌트가 여러개의 루트 엘리먼트를 반환하는 것은 jsx 문법상 불가능 하기 때문에,
이때 여러 요소들을 한번에 감쌀 수 있도록 React Fragment를 사용합니다.

하나의 요소로 감싸야 하는 이유는 Virtual DOM에서 컴포넌트 변화를 감지해 낼 때 효율적으로 비교할 수 있도록 컴포넌트 내부는 하나의 DOM 트리 구조로 이루어져야 한다는 규칙이 있기 때문입니다.

이를 이용해 의미없는 div 태그를 사용하지 않을 수 있으며, Fragment 태그 또한 key를 할당할 수 있습니다.

## 상태를 관리하는 훅인 useState와 useReducer의 특징과 차이를 설명해주세요.

우선 가장 큰 차이점은 useState는 다음 상태를 직접 지정하지만, useReducer는 액션이라는 객체를 기반으로 상태를 변경합니다.

또한, state가 단순한 값 혹은 객체를 관리한다면 useState를 사용하는것이 좋지만,
관리하는 상태가 점점 더 복잡해질수록 컴포넌트 내에 존재하는 상태관리 로직을 분리하기 위해 useReducer를 사용할 수 있습니다.

또한 상태 관리 로직의 일부를 재사용할 수 있기 때문에 다른 컴포넌트에서도 useState 보다 좀 더 간단하게 사용할 수 있습니다.

하지만 useReducer는 기본적으로 작성해야 하는 dispatch, reducer 함수에 의해 작성해야 하는 코드가 많아져
간단한 상태관리의 경우 useState가 더 좋은 선택일 수 있습니다.

## 불필요한 렌더링 방지를 위해 어떤 방법을 활용할 수 있나요?
